# Часть 1: Design Patterns
### 1) Описание Singleton Design Pattern

**Singleton** - это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Это полезно, когда у вас есть объект, который должен быть общим для всей системы, и вы хотите избежать создания множества экземпляров этого объекта.

### Псевдо UML диаграмма

```plaintext
+----------------------------+
|         Singleton          |
+----------------------------+
| - instance: Singleton      |
+----------------------------+
| + getInstance(): Singleton |
+----------------------------+
```

# Часть 2: ООП

### 2) Что такое ООП декомпозиция? Приведите примеры.

Объектно-ориентированная декомпозиция (ООП декомпозиция) - это процесс разбиения сложных систем на более мелкие и управляемые части, которые называются объектами. ООП позволяет абстрагировать и организовать код с помощью объектов, которые объединяют данные (поля) и функции (методы), обрабатывающие эти данные.

### 5) Что такое агрегация? Когда нужно применять наследование, а когда агрегацию?

**Агрегация** и **наследование** - это два различных концепта в объектно-ориентированном программировании, и каждый из них имеет свои собственные сценарии применения.

**Агрегация** - это отношение между объектами, где один объект содержит или "ссылается" на другой объект внутри себя. Он используется, когда один объект представляет часть или компоненту более крупной сущности. Агрегация подразумевает, что сущности могут существовать независимо друг от друга. Примеры агрегации могут включать в себя отношения между автомобилем и его двигателем, школой и учебным классом, компьютером и клавиатурой.

**Наследование** - это механизм, при котором класс может наследовать свойства и методы от другого класса. Он используется для создания нового класса, который является расширением или специализацией существующего класса. Наследование создает иерархию классов, где подкласс (или производный класс) наследует атрибуты и методы от надкласса (или базового класса). Примеры наследования включают в себя классы "Птица" и "Известная птица", где "Известная птица" наследует общие свойства от "Птица" и добавляет собственные.

#### **Когда использовать наследование и агрегацию зависит от конкретной ситуации:**

- **Наследование** используется, когда существует явная иерархия классов и подкласс является специализацией базового класса. Наследование полезно, когда один класс может использовать и переопределять функциональность другого класса.


- **Агрегация** используется, когда объекты связаны, но не имеют иерархических отношений. Он позволяет создавать более гибкие и составные структуры, где объекты могут быть переиспользованы в разных контекстах.

### 8) Что такое Абстрагирование? Почему Гради Буч ввел Абстр


**Абстрагирование** - это процесс упрощения сложных систем путем создания высокоуровневого представления объектов и их характеристик, исключая ненужные детали реализации. В объектно-ориентированном программировании (ООП) абстрагирование позволяет разработчикам сосредотачиваться на ключевых аспектах объектов и их взаимодействия, игнорируя сложные технические детали.

Гради Буч, известный компьютерный ученый и создатель Unified Modeling Language (UML), представил концепцию абстракции в программировании и методологиях разработки.

#### **Вот почему абстрагирование важно:**

1. **Упрощение сложных систем:** Абстрагирование упрощает сложные системы, сосредотачиваясь на ключевых компонентах и уменьшая сложность системы.
2. **Повышение понимания:** Абстрагирование помогает лучше понимать систему, убирая избыточные детали, улучшая коммуникацию и сотрудничество.
3. **Создание универсальных решений:** Абстракция позволяет создавать универсальные решения, которые могут быть использованы в разных контекстах.
4. **Моделирование:** Абстракция важна для создания моделей, которые описывают систему на высоком уровне. Эти модели используются для анализа, проектирования и документирования системы.

### 12) Что такое функциональное программирование? Приведите примеры использования функционального программировании.


**Функциональное программирование (FP)** - это парадигма программирования, где функции играют ключевую роль. Они могут передаваться, возвращаться из других функций и присваиваться переменным. Основной принцип FP - избегать изменения данных и побочных эффектов, фокусируясь на создании функций, которые принимают входные данные и возвращают результат, не меняя состояния окружающей системы.

1. **Функции как объекты первого класса:** В функциональном программировании функции могут быть переданы в качестве аргументов другим функциям. Например, в Python можно использовать функции map, filter и reduce для обработки списков.

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))  # Применить функцию к каждому элементу списка
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # Фильтрация элементов
sum_of_numbers = reduce(lambda x, y: x + y, numbers)  # Свертка (reduce) списка
```

2. **Рекурсия:** Функциональное программирование активно использует рекурсию для решения задач. Пример - вычисление факториала с использованием рекурсивной функции.

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```

3. **ямбда-функции и замыкания:** В функциональном программировании часто используются анонимные функции (лямбда-функции) и замыкания для создания функций на лету.

```python
# Пример лямбда-функции в Python
add = lambda x, y: x + y
result = add(2, 3)  # Результат - 5
```

Функциональное программирование может улучшить читаемость, обеспечить безопасность и сделать код более предсказуемым, что делает его популярным для решения ряда задач, включая обработку данных, параллельное программирование и создание распределенных систем.

# Часть 3: Элементы промышленного программирования

### 1) Пирамида тестирования? Определение, физический смысл, примеры.

**Пирамида тестирования** - это модель, которая описывает баланс различных видов тестов в разработке ПО. Она предполагает, что большинство тестов должны быть автоматизированными и находиться на низком уровне, а менее тестов - на более высоких уровнях.

#### **Примеры:**

1) **Модульные тесты** проверяют отдельные части кода, например, функции или методы.

2) **Интеграционные тесты** проверяют, как различные компоненты взаимодействуют друг с другом.

3) **Тесты конечного использования** проверяют, как система работает в реальных условиях использования, например, как веб-приложение отвечает на действия пользователей.


### 3) «Магическое число» 7 +-2. Связь с «магическим числом» и цикломатической сложностью.

**"Магическое число" 7 ± 2** - это термин, связанный с цикломатической сложностью и метрикой, предложенной Томасом МакКейбом. Она используется для оценки сложности программного кода на основе структуры его управляющих потоков. Цикломатическая сложность позволяет определить количество тестовых случаев, необходимых для достижения полного покрытия кода.

#### **Цикломатическая сложность оценивается с помощью формулы:**
```css
M = E - N + 2P
```
- M - цикломатическая сложность,
- E - количество рёбер (переходов) в графе управления потоком,
- N - количество узлов (блоков) в графе управления потоком,
- P - количество компонент связности в графе управления потоком.

Идея "магического числа" 7 ± 2 заключается в том, что цикломатическая сложность кода должна быть в пределах этого диапазона (5 ≤ M ≤ 10). Если M меньше 5, это может означать, что код слишком прост, и его тестирование может быть недостаточным. Если M больше 10, это может указывать на чрезмерную сложность и потенциально более трудное тестирование.

### 6) Что такое Test Runner, дайте определение, приведите примеры Java Frameworks.

**Test Runner (запускающая программа тестов)** - это инструмент или программа, которая автоматизирует выполнение тестовых сценариев во время тестирования программного обеспечения. Он управляет запуском тестов, сбором результатов и предоставляет отчеты о выполнении тестов.

#### **Примеры фреймворков для запуска тестов на языке Java:**

1. **JUnit:** Один из самых популярных фреймворков для юнит-тестирования в Java. JUnit предоставляет аннотации и классы для создания и запуска тестов.
```javascript
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class MyTest {
    @Test
    public void testAddition() {
        assertEquals(4, 2 + 2);
    }
}
```

2. **TestNG:** Еще один популярный фреймворк для тестирования Java-приложений. TestNG предоставляет более широкие возможности для тестирования, включая группировку тестов, параллельное выполнение и настраиваемые отчеты.

```javascript
import org.testng.annotations.Test;
import org.testng.Assert;

public class MyTest {
    @Test
    public void testSubtraction() {
        Assert.assertEquals(5, 7 - 2);
    }
}

```
Test Runner в этих фреймворках автоматически находит и выполняет тестовые методы, а также генерирует отчеты о результатах выполнения тестовых сценариев.

### 9) Что такое Reflection в Java? Как используется в контексте Mock frameworks?

**Reflection** в Java - это механизм, который позволяет программам анализировать и манипулировать классами, объектами, методами и полями во время выполнения. С помощью рефлексии можно получать информацию о структуре классов, создавать экземпляры классов, вызывать методы и обращаться к полям, даже если эти элементы являются закрытыми (private).

В контексте **Mock-фреймворков** (фреймворков для создания заместителей или заглушек для тестирования) рефлексия используется для создания и настройки макетов (mocks) или объектов-заглушек. Заглушки могут имитировать поведение реальных объектов, чтобы упростить и ускорить тестирование. Рефлексия позволяет создавать заглушки для классов и интерфейсов, которые могут быть интегрированы в юнит-тесты.

#### **Пример использования рефлексии в контексте mock-фреймворков:**

```javascript
import org.mockito.Mockito;
import java.lang.reflect.Field;

public class Example {
    private SomeClass someObject;

    public void setSomeObject(SomeClass someObject) {
        this.someObject = someObject;
    }
}

public class MockTest {
    public static void main(String[] args) {
        Example example = new Example();
        
        // Создаем макет (mock) для SomeClass
        SomeClass mockSomeClass = Mockito.mock(SomeClass.class);
        
        // Используем рефлексию для установки mockSomeClass в private поле someObject
        try {
            Field field = example.getClass().getDeclaredField("someObject");
            field.setAccessible(true);
            field.set(example, mockSomeClass);
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        // Теперь example.someObject будет ссылаться на mockSomeClass
    }
}
```
В этом примере мы создаем макет (mock) для класса **SomeClass** и используем рефлексию для установки этого макета в private поле **someObject** объекта **example**. Это позволяет нам контролировать поведение **someObject** и тестировать **Example** с использованием заглушек.
